import React from 'react'
import withStatefulProps from './react-stateful-props'

let injectSheet;
/**
 *  configuration object; allows us to set a global jss instance
 *  and presets
 * @type {{setInjector: ((injector))}}
 */
export const jssTransitionConfig = {
    setInjector (injector) {
        injectSheet = injector;
    }
};

const generateStyleSheet = ({ styleStates })=> {
    try {

    console.log('generateStyleSheet.styleStates ->', styleStates);

    /**
     * tracks rule->prop instances to conveniently
     * iterate through for custom behaviors;
     * format: rule->prop->[...statesUsingProp]
     **/
    const rulePropTracker = {};

    // iterate through all rules, then all props,
    // so that we can find the consistent ones
    // accross each styleState

    Object.keys(styleStates).forEach( stateKey => {

        const stateStylesheet = styleStates[stateKey].styleSheet;
        Object.keys(stateStylesheet).forEach( ruleName=> {
            rulePropTracker[ruleName] = rulePropTracker[ruleName] || {};
            const rule = rulePropTracker[ruleName];

            Object.keys(stateStylesheet[ruleName]).forEach((propName)=>{
                console.log(`${stateKey}::${ruleName} ->`, propName)
                rule[propName] = rule[propName] || [];
                rule[propName].push(stateKey);
            });
        });
    });

    console.log('rulePropTracker ->', rulePropTracker);

    // Now iterate through all of these and add proper behavior
    // to callback functions

    const generatedSheet = {};

    Object.keys(rulePropTracker).forEach( ruleKey => {

        // inject dynamic behavior with callback to additional
        // styleState checked against from function value
        // context props

        const rule = rulePropTracker[ruleKey];

        Object.keys(rule).forEach( styleKey => {

            // return the function value needed for the
            // specific rule's style property

            const stylePropBehavior = ()=> {
                return ({ setStatefulProps, styleState='default', ...statefulProps }) => {
                    const activeStyleState = styleStates[styleState];

                    // when rendering, re-run prop behavior
                    if(activeStyleState && activeStyleState.behavior) {
                        /*activeStyleState.behavior({
                            setStatefulProps,
                            statefulProps : { styleState, ...statefulProps }
                        });*/
                    }

                    if(activeStyleState.styleSheet[ruleKey] && activeStyleState.styleSheet[ruleKey][styleKey]) {
                        switch(typeof activeStyleState.styleSheet[ruleKey][styleKey]) {
                            case 'string':
                            case 'number':
                                return activeStyleState.styleSheet[ruleKey][styleKey];
                            case 'function':
                                return activeStyleState.styleSheet[ruleKey][styleKey]({ setStatefulProps, ...statefulProps });
                            default : 
                                console.log('rule and style not found ->', ruleKey + ':' + styleKey);
                                break;
                        }
                        if(typeof activeStyleState.styleSheet[ruleKey][styleKey] != 'undefined') {
                            return styleStates[styleState];
                        }
                    } else {
                        throw new Error(
                            `JSSX : no style @ the state ${styleState} for ` +
                            `the rule ${ruleKey} at property ${styleKey}`
                        );
                    }
                };
            };

            generatedSheet[ruleKey] = generatedSheet[ruleKey] || {};
            generatedSheet[ruleKey][styleKey] = stylePropBehavior();
        });
    });

    // iterate through each style state
    Object.keys(styleStates).map((state)=>{
        //iterate through each style property
        Object.keys(styleStates[state].styleSheet).map( ruleName => {
            switch(typeof styleStates[state][ruleName]) {
                case 'string':
                case 'number':
                    // return simple value
                    break;
                case 'function':

                    break;
            }
        });
    });
    return generatedSheet;

} catch( error ) {
    console('WHATEVER :D ->', error);
}

};

/**
 *
 * @param p
 * @param p.styleStates
 * @param p.options
 * 
 * @return new component which can receive classes
 *              generated by JSS & Transformer to provide
 */
export const injectJSSBehavior = ({ styleStates, options = {}})=> {
    return (WrappedComponent)=> {
        const generatedStyleSheet = generateStyleSheet({ styleStates });
        const ComponentDisplayed = injectSheet(generatedStyleSheet)(WrappedComponent);
        //TODO : hoist non static vars w lib
        return withStatefulProps(ComponentDisplayed)({
            onSetStatefulProps ({ statefulProps, props }) {
                console.log('onSetStatefulProps ->', statefulProps, props);
                const { styleState } = statefulProps;
                if(styleState) {
                    styleStates[styleState].behavior(props);
                }
            },
            statefulProps : { styleState : 'default' },
            component : ComponentDisplayed
        });
    };
};

export default injectJSSBehavior;